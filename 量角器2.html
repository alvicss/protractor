<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç©ä¸€ä¸‹é‡è§’å™¨</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', 'Fredoka One', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* ç¢ºä¿ä½”æ»¿æ•´å€‹è¦–çª—é«˜åº¦ */
            margin: 0;
            background: linear-gradient(to bottom right, #87CEEB, #F0F8FF); /* å¯æ„›çš„å¤©ç©ºæ¼¸å±¤èƒŒæ™¯ */
            overflow: hidden; /* éš±è—æ»¾å‹•æ¢ */
        }
        h1 {
            color: #FF69B4; /* å¯æ„›ç²‰è‰² */
            text-shadow: 2px 2px 0px #FFF, 4px 4px 0px #FFD700; /* è®“æ¨™é¡Œæ›´çªå‡º */
            margin-bottom: 20px;
            font-size: 3.5em; /* æ›´å¤§çš„æ¨™é¡Œ */
            font-family: 'Fredoka One', cursive;
        }
        #app-container {
            display: flex;
            background-color: #fff;
            border-radius: 25px; /* åœ“æ½¤çš„é‚Šæ¡† */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); /* æŸ”å’Œé™°å½± */
            padding: 25px;
            max-width: 90vw; /* é™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œé¿å…éå¯¬ */
            max-height: 90vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            box-sizing: border-box;
            flex-grow: 1;
        }
        #controls {
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* æ§åˆ¶é …åˆ†ä½ˆå‡å‹» */
            align-items: center;
            padding: 20px;
            background-color: #ffe0f0; /* ç²‰è‰²ç³»æ§åˆ¶å€èƒŒæ™¯ */
            border-radius: 15px;
            margin-right: 25px;
            flex-shrink: 0; /* ä¸å£“ç¸® */
            width: 250px; /* å›ºå®šæ§åˆ¶å€å¯¬åº¦ */
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            width: 100%;
        }
        .control-group label {
            font-size: 1.5em;
            color: #FF1493; /* æ·±ç²‰è‰² */
            margin-bottom: 10px;
            font-weight: bold;
        }
        canvas {
            border: 5px dashed #FFD700; /* å¯æ„›è™›ç·šé‚Šæ¡† */
            background-color: #F8F8FF; /* æ·ºè‰²èƒŒæ™¯ */
            cursor: grab;
            border-radius: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);
        }
        button {
            padding: 15px 25px;
            font-size: 1.5em;
            cursor: pointer;
            background-color: #7B68EE; /* è–°è¡£è‰è— */
            color: white;
            border: none;
            border-radius: 30px; /* æ›´åœ“æ½¤çš„æŒ‰éˆ• */
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            font-family: 'Fredoka One', cursive;
            margin-top: 10px;
            width: 80%; /* è®“æŒ‰éˆ•å¯¬åº¦ä¸€è‡´ */
        }
        button:hover {
            background-color: #6A5ACD; /* ç¨å¾®æ·±ä¸€é»çš„è— */
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        #newQuestionBtn { background-color: #FFA07A; } /* æ©™è‰² */
        #newQuestionBtn:hover { background-color: #FF8C00; }
        #resetBtn { background-color: #9370DB; } /* ç´«è‰² */
        #resetBtn:hover { background-color: #8A2BE2; }
        #checkAnswerBtn { background-color: #5DADE2; } /* æ·ºè—è‰² */
        #checkAnswerBtn:hover { background-color: #3498DB; }

        input[type="number"] {
            padding: 12px;
            font-size: 1.5em;
            border: 3px solid #FFD700; /* é‡‘è‰²é‚Šæ¡† */
            border-radius: 15px;
            width: 100px;
            text-align: center;
            background-color: #FFFACD; /* æª¸æª¬ç¶¢è‰² */
            color: #4B0082; /* æ·±ç´«è‰²æ–‡å­— */
            font-family: 'Fredoka One', cursive;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            -moz-appearance: textfield; /* éš±è—Firefoxçš„ä¸Šä¸‹ç®­é ­ */
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; /* éš±è—Chrome/Safariçš„ä¸Šä¸‹ç®­é ­ */
            margin: 0;
        }

        #feedback-display {
            margin-top: 15px;
            font-size: 2em;
            font-weight: bold;
            color: #FF4500; /* åˆå§‹æ©˜ç´…è‰² */
            min-height: 40px; /* é ç•™ç©ºé–“ */
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .feedback-success { color: #32CD32; animation: tada 0.8s; } /* æˆåŠŸç¶  */
        .feedback-error { color: #FF4500; animation: shake 0.5s; } /* éŒ¯èª¤ç´… */
        .feedback-info { color: #4169E1; } /* æç¤ºè— */

        /* å‹•ç•«æ•ˆæœ */
        @keyframes tada {
            from { transform: scale3d(1, 1, 1); }
            10%, 20% { transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg); }
            30%, 50%, 70%, 90% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg); }
            40%, 60%, 80% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg); }
            to { transform: scale3d(1, 1, 1); }
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
            50% { transform: translate3d(-4px, 0, 0); }
        }
    </style>
</head>
<body>
    <h1>ğŸŒŸ ç©ä¸€ä¸‹é‡è§’å™¨ ğŸŒŸ</h1>
    <div id="app-container">
        <div id="controls">
            <div class="control-group">
                <button id="newQuestionBtn">âœ¨ æ–°é¡Œç›®</button>
                <button id="resetBtn">â†©ï¸ é‡æ–°æ“ºæ”¾</button>
            </div>
            <div class="control-group">
                <label for="angleInput">ä½ çš„ç­”æ¡ˆï¼š</label>
                <input type="number" id="angleInput" min="5" max="180" step="5" placeholder="è¼¸å…¥è§’åº¦">
                <button id="checkAnswerBtn">âœ… æª¢æŸ¥ç­”æ¡ˆ</button>
            </div>
            <div id="feedback-display"></div>
        </div>
        <canvas id="myCanvas" width="960" height="540"></canvas> <!-- 16:9 æ¯”ä¾‹ -->
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const newQuestionBtn = document.getElementById('newQuestionBtn');
        const resetBtn = document.getElementById('resetBtn');
        const angleInput = document.getElementById('angleInput');
        const checkAnswerBtn = document.getElementById('checkAnswerBtn');
        const feedbackDisplay = document.getElementById('feedback-display');

        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;

        let correctAnswer = 0; // å­˜æ”¾ç•¶å‰é¡Œç›®çš„æ­£ç¢ºç­”æ¡ˆ (åº¦æ•¸)
        let angleLines = {
            center: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            line1: { x: 0, y: 0 },
            line2: { x: 0, y: 0 }
        };
        let initialAngleLines = null; // ç”¨æ–¼å„²å­˜åˆå§‹é¡Œç›®ç‹€æ…‹

        // é‡è§’å™¨å±¬æ€§
        const protractorRadius = 180; // èª¿æ•´é‡è§’å™¨å¤§å°ä»¥é©æ‡‰æ–°ç•«å¸ƒ
        let protractor = {
            x: CANVAS_WIDTH - protractorRadius - 80, // åˆå§‹ä½ç½®èª¿æ•´åˆ°å³ä¸‹è§’ï¼Œä¸¦æœ‰æ›´å¤šé‚Šè·
            y: CANVAS_HEIGHT - protractorRadius - 80,
            rotation: 0, // æ—‹è½‰è§’åº¦ (å¼§åº¦)
            isDragging: false,
            isRotating: false,
            dragOffsetX: 0,
            dragOffsetY: 0,
            isAligned: false // æ˜¯å¦å·²å°é½Šå¤¾è§’é ‚é»
        };

        // --- ç¹ªåœ–å‡½æ•¸ ---

        // ç¹ªè£½å¤¾è§’ç·š
        function drawAngleLines(center, p1, p2) {
            ctx.strokeStyle = '#4A90E2'; // äº®è—è‰²
            ctx.lineWidth = 6; // æ›´ç²—çš„ç·šæ¢
            ctx.lineCap = 'round'; // åœ“é ­ç·šæ¢
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // ç¹ªè£½å¤¾è§’é ‚é» (å¯æ„›æ˜Ÿæ˜Ÿ)
            drawStar(center.x, center.y, 12, 25, 10, '#FFD700'); // å¤§é»ƒæ˜Ÿ
        }

        // ç¹ªè£½æ˜Ÿæ˜Ÿå‡½æ•¸
        function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#DAA520'; // è¼ƒæ·±é»ƒè‰²é‚Šæ¡†
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // ç¹ªè£½é‡è§’å™¨
        function drawProtractor() {
            ctx.save();
            ctx.translate(protractor.x, protractor.y);
            ctx.rotate(protractor.rotation);

            // ç¹ªè£½åŠåœ“èƒŒæ™¯ (æ›´æŸ”å’Œçš„é¡è‰²)
            ctx.beginPath();
            ctx.arc(0, 0, protractorRadius, Math.PI, 0, false);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // æ›´é€æ˜ï¼Œåƒç»ç’ƒ
            ctx.fill();
            ctx.strokeStyle = '#A9A9A9'; // ç°è‰²é‚Šæ¡†
            ctx.lineWidth = 3;
            ctx.stroke();

            // ç¹ªè£½é‡è§’å™¨ä¸­å¿ƒé» (å°åœ“åœˆ)
            ctx.fillStyle = '#6A5ACD'; // ç´«è‰²ä¸­å¿ƒé»
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#483D8B';
            ctx.lineWidth = 2;
            ctx.stroke();


            // ç¹ªè£½åˆ»åº¦è¼”åŠ©å‡½æ•¸
            const drawTick = (rad, length, color, lineWidth = 2) => {
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(0 - protractorRadius * cos, 0 - protractorRadius * sin);
                ctx.lineTo(0 - (protractorRadius + length) * cos, 0 - (protractorRadius + length) * sin);
                ctx.stroke();
            };

            // ç¹ªè£½åˆ»åº¦
            const outerColor = '#36454F'; // ç‚­ç°è‰²
            const innerColor = '#B22222'; // ç«ç£šç´…
            const textOffsetOuter = protractorRadius + 20; // èª¿æ•´æ–‡å­—åç§»
            const textOffsetInner = protractorRadius - 20;
            ctx.font = 'bold 18px "Fredoka One", cursive'; // å¯æ„›ç²—é«”å­—
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i <= 180; i += 5) {
                const rad = Math.PI - (i * Math.PI / 180);
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);

                let lineLength = 7; // 5åº¦åˆ»åº¦é•·åº¦
                
                if (i % 10 === 0) {
                    lineLength = 12; // 10åº¦åˆ»åº¦é•·åº¦
                    // ç¹ªè£½å¤–åœˆåˆ»åº¦ç·šåŠæ•¸å­— (0, 10, ... 180)
                    drawTick(rad, lineLength, outerColor, 3); // æ›´ç²—
                    ctx.fillStyle = outerColor;
                    ctx.fillText(i.toString(), 0 - textOffsetOuter * cos, 0 - textOffsetOuter * sin);

                    // ç¹ªè£½å…§åœˆåˆ»åº¦ç·šåŠæ•¸å­— (180, 170, ... 0)
                    drawTick(rad, -lineLength, innerColor, 3); // å‘å…§ï¼Œæ›´ç²—
                    ctx.fillStyle = innerColor;
                    ctx.fillText((180 - i).toString(), 0 - textOffsetInner * cos, 0 - textOffsetInner * sin);

                } else { // 5åº¦åˆ»åº¦
                    drawTick(rad, lineLength, '#808080'); // ç°è‰²
                }
            }

            ctx.restore();
        }

        // æ¸…é™¤ç•«å¸ƒ
        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        // å®Œæ•´ç¹ªè£½æ‰€æœ‰å…§å®¹
        function drawAll() {
            clearCanvas();
            drawAngleLines(angleLines.center, angleLines.line1, angleLines.line2);
            drawProtractor();
        }

        // --- è¼”åŠ©å‡½æ•¸ ---

        // ç”¢ç”Ÿéš¨æ©Ÿè§’åº¦ (åº¦æ•¸)ï¼Œä¸”æ˜¯5çš„å€æ•¸
        function getRandomAngleDegrees() {
            const angleDegrees = Math.floor(Math.random() * ( (180 - 5) / 5 + 1)) * 5 + 5;
            correctAnswer = angleDegrees; // å„²å­˜æ­£ç¢ºç­”æ¡ˆ
            return angleDegrees;
        }

        // ç”Ÿæˆæ–°é¡Œç›®
        function generateNewQuestion() {
            clearCanvas();
            feedbackDisplay.textContent = ''; // æ¸…é™¤å›é¥‹è¨Šæ¯
            feedbackDisplay.className = '';
            angleInput.value = ''; // æ¸…é™¤è¼¸å…¥æ¡†

            // é‡ç½®é‡è§’å™¨ä½ç½®å’Œç‹€æ…‹
            protractor.x = CANVAS_WIDTH - protractorRadius - 80;
            protractor.y = CANVAS_HEIGHT - protractorRadius - 80;
            protractor.rotation = 0;
            protractor.isAligned = false;
            updateCursor(); // æ›´æ–°æ¸¸æ¨™

            // éš¨æ©Ÿç”Ÿæˆå¤¾è§’
            const angleDegrees = getRandomAngleDegrees();
            const angleRad = angleDegrees * Math.PI / 180;

            // ç¢ºä¿å…©æ¢ç·šä¸æœƒé‡ç–Šï¼Œä¸”å¤¾è§’åœ¨ç•«å¸ƒç¯„åœå…§
            const lineLength = 200; // ç·šçš„é•·åº¦
            const startAngle1 = Math.random() * Math.PI * 2; // ç¬¬ä¸€æ¢ç·šçš„èµ·å§‹è§’åº¦

            // ç¬¬äºŒæ¢ç·šçš„è§’åº¦åŸºæ–¼ç¬¬ä¸€æ¢ç·šå’Œå¤¾è§’
            let startAngle2 = startAngle1 + angleRad;

            angleLines.line1.x = angleLines.center.x + lineLength * Math.cos(startAngle1);
            angleLines.line1.y = angleLines.center.y + lineLength * Math.sin(startAngle1);
            angleLines.line2.x = angleLines.center.x + lineLength * Math.cos(startAngle2);
            angleLines.line2.y = angleLines.center.y + lineLength * Math.sin(startAngle2);

            initialAngleLines = JSON.parse(JSON.stringify(angleLines)); // å„²å­˜åˆå§‹ç‹€æ…‹
            drawAll();
            displayFeedback('æ‹–å‹•é‡è§’å™¨åˆ°é»ƒè‰²æ˜Ÿæ˜Ÿä¸Šï¼', 'info');
        }

        // æª¢æŸ¥é‡è§’å™¨ä¸­å¿ƒæ˜¯å¦æ¥è¿‘å¤¾è§’é ‚é»
        function isNearVertex(x, y) {
            const dist = Math.sqrt(
                Math.pow(x - angleLines.center.x, 2) +
                Math.pow(y - angleLines.center.y, 2)
            );
            return dist < 30; // å¢å¤§é–¾å€¼ï¼Œè®“å°é½Šæ›´å®¹æ˜“
        }

        // æ›´æ–°æ¸¸æ¨™æ¨£å¼
        function updateCursor() {
            if (!protractor.isAligned) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'ew-resize';
            }
        }

        // é¡¯ç¤ºå›é¥‹è¨Šæ¯
        function displayFeedback(message, type) {
            feedbackDisplay.textContent = message;
            feedbackDisplay.className = ''; // æ¸…é™¤èˆŠçš„é¡å
            if (type === 'success') {
                feedbackDisplay.classList.add('feedback-success');
            } else if (type === 'error') {
                feedbackDisplay.classList.add('feedback-error');
            } else if (type === 'info') {
                feedbackDisplay.classList.add('feedback-info');
            }
        }

        // --- äº‹ä»¶è™•ç† ---

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const distToProtractorCenter = Math.sqrt(
                Math.pow(mouseX - protractor.x, 2) +
                Math.pow(mouseY - protractor.y, 2)
            );

            if (distToProtractorCenter <= protractorRadius + 20) { // å¢å¤§é»æ“Šç¯„åœ
                if (!protractor.isAligned) {
                    protractor.isDragging = true;
                    protractor.dragOffsetX = mouseX - protractor.x;
                    protractor.dragOffsetY = mouseY - protractor.y;
                    canvas.style.cursor = 'grabbing';
                } else {
                    protractor.isRotating = true;
                    const angleToMouse = Math.atan2(mouseY - protractor.y, mouseX - protractor.x);
                    protractor.rotationOffset = protractor.rotation - angleToMouse;
                    canvas.style.cursor = 'ew-resize';
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (protractor.isDragging) {
                protractor.x = mouseX - protractor.dragOffsetX;
                protractor.y = mouseY - protractor.dragOffsetY;

                if (isNearVertex(protractor.x, protractor.y)) {
                    protractor.x = angleLines.center.x;
                    protractor.y = angleLines.center.y;
                    protractor.isAligned = true;
                    protractor.isDragging = false;
                    displayFeedback('é‡è§’å™¨å·²å°é½Šï¼ç¾åœ¨å¯ä»¥æ—‹è½‰å›‰ï¼', 'success');
                    updateCursor();
                }
                drawAll();
            } else if (protractor.isRotating) {
                const angleToMouse = Math.atan2(mouseY - protractor.y, mouseX - protractor.x);
                protractor.rotation = angleToMouse + protractor.rotationOffset;
                drawAll();
            }
        });

        canvas.addEventListener('mouseup', () => {
            protractor.isDragging = false;
            protractor.isRotating = false;
            updateCursor();
        });

        canvas.addEventListener('mouseleave', () => {
            // å¦‚æœæ»‘é¼ é›¢é–‹ç•«å¸ƒæ™‚é‚„åœ¨æ‹–æ›³æˆ–æ—‹è½‰ï¼Œä¹Ÿåœæ­¢
            if (protractor.isDragging || protractor.isRotating) {
                protractor.isDragging = false;
                protractor.isRotating = false;
                updateCursor();
            }
        });


        newQuestionBtn.addEventListener('click', generateNewQuestion);

        resetBtn.addEventListener('click', () => {
            if (initialAngleLines) {
                clearCanvas();
                angleLines = JSON.parse(JSON.stringify(initialAngleLines));
                
                // é‡ç½®é‡è§’å™¨ä½ç½®å’Œç‹€æ…‹
                protractor.x = CANVAS_WIDTH - protractorRadius - 80;
                protractor.y = CANVAS_HEIGHT - protractorRadius - 80;
                protractor.rotation = 0;
                protractor.isAligned = false;
                updateCursor();
                
                displayFeedback('é‡è§’å™¨å›åˆ°èµ·é»äº†ï¼', 'info');
                angleInput.value = '';
                drawAll();
            }
        });

        checkAnswerBtn.addEventListener('click', () => {
            const userAnswer = parseInt(angleInput.value);
            if (isNaN(userAnswer)) {
                displayFeedback("è«‹è¼¸å…¥ä¸€å€‹æ•¸å­—å–”ï¼", 'error');
                return;
            }

            if (Math.abs(userAnswer - correctAnswer) <= 1) { 
                displayFeedback("æ­å–œä½ ç­”å°äº†ï¼å¤ªæ£’äº†ï¼ğŸ‰", 'success');
            } else {
                //displayFeedback(`å†æƒ³æƒ³çœ‹å–”ï¼æ­£ç¢ºç­”æ¡ˆæ˜¯ ${correctAnswer} åº¦ ğŸ˜‰`, 'error');
				displayFeedback(`å†æƒ³æƒ³çœ‹å–”ï¼ğŸ˜‰`, 'error');
            }
            drawAll();
        });

        // é¦–æ¬¡è¼‰å…¥é é¢æ™‚ç”Ÿæˆä¸€å€‹é¡Œç›®
        generateNewQuestion();
    </script>
</body>
</html>